# A classe BTreeNode representa um único nó da nossa Árvore B.
class BTreeNode:
    def __init__(self, leaf=False):
        self.keys = []  # Lista para armazenar as chaves (valores) do nó.
        self.child = [] # Lista para armazenar os filhos do nó.
        self.leaf = leaf # Flag que indica se o nó é uma folha (não tem filhos).

# A classe BTree representa a estrutura completa da árvore.
class BTree:
    def __init__(self, t):
        self.root = BTreeNode(True) # O nó raiz é inicialmente uma folha.
        self.t = t # O grau mínimo da árvore (mínimo de chaves em um nó é t-1).

    # Insere uma nova chave na árvore.
    def insert(self, k):
        root = self.root
        # Se a raiz está cheia, a árvore cresce em altura.
        if len(root.keys) == (2 * self.t) - 1:
            temp = BTreeNode()
            self.root = temp
            temp.child.insert(0, root)
            self.split_child(temp, 0)
            self.insert_non_full(temp, k)
        else:
            self.insert_non_full(root, k)

    # Função auxiliar para inserir uma chave em um nó que não está cheio.
    def insert_non_full(self, x, k):
        i = len(x.keys) - 1
        # Se o nó é uma folha, a chave é inserida diretamente.
        if x.leaf:
            x.keys.append(k)
            x.keys.sort()
        # Se não é uma folha, encontra o filho correto para descer.
        else:
            while i >= 0 and k < x.keys[i]:
                i -= 1
            i += 1
            # Se o filho está cheio, divide-o antes de descer.
            if len(x.child[i].keys) == (2 * self.t) - 1:
                self.split_child(x, i)
                if k > x.keys[i]:
                    i += 1
            self.insert_non_full(x.child[i], k)

    # Divide um nó filho que está cheio.
    def split_child(self, x, i):
        t = self.t
        y = x.child[i]
        z = BTreeNode(y.leaf)
        x.child.insert(i + 1, z)
        x.keys.insert(i, y.keys[t - 1]) # A chave do meio sobe para o pai.
        z.keys = y.keys[t:] # A nova metade do nó filho vai para o novo nó.
        y.keys = y.keys[:t - 1] # A primeira metade do nó filho original permanece.
        if not y.leaf:
            z.child = y.child[t:]
            y.child = y.child[:t]

    # Busca uma chave na árvore.
    def search(self, k, x=None):
        if x is None:
            x = self.root

        i = 0
        # Encontra a posição da chave ou o ponteiro para o filho correto.
        while i < len(x.keys) and k > x.keys[i]:
            i += 1
        
        # Se a chave for encontrada no nó atual, retorna o nó.
        if i < len(x.keys) and k == x.keys[i]:
            return x
        # Se é uma folha e a chave não foi encontrada, ela não existe na árvore.
        elif x.leaf:
            return None
        # Continua a busca no filho apropriado.
        else:
            return self.search(k, x.child[i])

    # Remove uma chave da árvore.
    def delete(self, k):
        self.delete_key(self.root, k)
        
        # CORREÇÃO: Após a deleção, verifica se a raiz ficou vazia
        # (caso em que a raiz foi fundida).
        if len(self.root.keys) == 0 and not self.root.leaf:
            self.root = self.root.child[0]

    # Função auxiliar para a deleção recursiva.
    def delete_key(self, x, k):
        t = self.t
        i = 0
        while i < len(x.keys) and k > x.keys[i]:
            i += 1
        
        # Caso 1: A chave está no nó folha.
        if x.leaf:
            if i < len(x.keys) and k == x.keys[i]:
                x.keys.pop(i)
                print(f'Chave {k} removida com sucesso.')
            else:
                print(f'Chave {k} não encontrada na árvore.')
        # Caso 2: A chave está em um nó interno.
        else:
            if i < len(x.keys) and k == x.keys[i]:
                self.delete_internal_node(x, k, i)
            # Caso 3: A chave não está no nó, desce para o filho.
            else:
                child = x.child[i]
                if len(child.keys) < t:
                    self.fill(x, i)
                self.delete_key(x.child[i], k)

    # Lógica para preencher um nó filho que ficou com poucas chaves (abaixo de t-1).
    def fill(self, x, i):
        t = self.t
        # Tenta pegar chaves de um irmão direito
        if i + 1 < len(x.child) and len(x.child[i + 1].keys) >= t:
            self.borrow_from_right(x, i)
        # Tenta pegar chaves de um irmão esquerdo
        elif i > 0 and len(x.child[i - 1].keys) >= t:
            self.borrow_from_left(x, i)
        # Se não pode emprestar, funde com um dos irmãos.
        else:
            if i + 1 < len(x.child):
                self.merge(x, i)
            else:
                self.merge(x, i - 1)

    # Empresta uma chave de um irmão à direita.
    def borrow_from_right(self, x, i):
        child = x.child[i]
        sibling = x.child[i + 1]
        child.keys.append(x.keys[i])
        x.keys[i] = sibling.keys.pop(0)
        if not child.leaf:
            child.child.append(sibling.child.pop(0))

    # Empresta uma chave de um irmão à esquerda.
    def borrow_from_left(self, x, i):
        child = x.child[i]
        sibling = x.child[i - 1]
        child.keys.insert(0, x.keys[i - 1])
        x.keys[i - 1] = sibling.keys.pop()
        if not child.leaf:
            child.child.insert(0, sibling.child.pop())

    # Funde um nó com seu irmão.
    def merge(self, x, i):
        child = x.child[i]
        sibling = x.child[i + 1]
        child.keys.append(x.keys.pop(i))
        child.keys.extend(sibling.keys)
        child.child.extend(sibling.child)
        x.child.pop(i + 1)
        
    # Método auxiliar para a deleção em nó interno.
    def delete_internal_node(self, x, k, i):
        t = self.t
        # Encontra o predecessor (maior chave no filho à esquerda).
        if len(x.child[i].keys) >= t:
            pred = self.get_predecessor(x.child[i])
            x.keys[i] = pred
            self.delete_key(x.child[i], pred)
        # Encontra o sucessor (menor chave no filho à direita).
        elif len(x.child[i + 1].keys) >= t:
            succ = self.get_successor(x.child[i + 1])
            x.keys[i] = succ
            self.delete_key(x.child[i + 1], succ)
        # Se nem o predecessor nem o sucessor podem ser encontrados, faz a fusão.
        else:
            self.merge(x, i)
            self.delete_key(x.child[i], k)

    # Busca a chave predecessora (maior chave no sub-nó da esquerda).
    def get_predecessor(self, x):
        while not x.leaf:
            x = x.child[-1]
        return x.keys[-1]

    # Busca a chave sucessora (menor chave no sub-nó da direita).
    def get_successor(self, x):
        while not x.leaf:
            x = x.child[0]
        return x.keys[0]

# --- Exemplo de uso do código ---
btree = BTree(t=3)

# Inserindo chaves na árvore
btree.insert(15)
btree.insert(25)
btree.insert(5)
btree.insert(10)
btree.insert(20)
btree.insert(30)
btree.insert(2)
btree.insert(8)
btree.insert(18)
btree.insert(22)
btree.insert(35)

# Buscando chaves
print(f"Busca por 30: {btree.search(30) is not None}") # Deve retornar True
print(f"Busca por 12: {btree.search(12) is not None}") # Deve retornar False

# Deletando chaves
btree.delete(8)
print(f"Busca por 8: {btree.search(8) is not None}") # Deve retornar False
