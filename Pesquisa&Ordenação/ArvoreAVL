# A classe Node representa um nó individual na Árvore AVL.
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1 # Altura inicial é 1 para um nó recém-criado.

# A classe AVLTree gerencia toda a estrutura da árvore.
class AVLTree:
    def __init__(self):
        self.root = None

    # Método público para inserção.
    def insert(self, key):
        self.root = self._insert_node(self.root, key)

    # Método auxiliar recursivo para inserção de um nó.
    def _insert_node(self, node, key):
        # 1. Realiza a inserção padrão de uma BST.
        if node is None:
            return Node(key)
        elif key < node.key:
            node.left = self._insert_node(node.left, key)
        elif key > node.key:
            node.right = self._insert_node(node.right, key)
        else: # Chaves duplicadas não são permitidas.
            return node

        # 2. Atualiza a altura do nó pai.
        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))

        # 3. Calcula o fator de balanceamento do nó.
        balance = self._get_balance(node)
        

        # 4. Se o nó está desbalanceado, executa a rotação apropriada.
        # Caso 1: Rotação Simples Direita (RR)
        if balance > 1 and key < node.left.key:
            return self._rotate_right(node)

        # Caso 2: Rotação Simples Esquerda (LL)
        if balance < -1 and key > node.right.key:
            return self._rotate_left(node)

        # Caso 3: Rotação Dupla Esquerda-Direita (LR)
        if balance > 1 and key > node.left.key:
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)

        # Caso 4: Rotação Dupla Direita-Esquerda (RL)
        if balance < -1 and key < node.right.key:
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)

        return node

    # Método público para deleção.
    def delete(self, key):
        self.root = self._delete_node(self.root, key)

    # Método auxiliar recursivo para deleção de um nó.
    def _delete_node(self, root, key):
        # 1. Realiza a deleção padrão de uma BST.
        if not root:
            return root
        elif key < root.key:
            root.left = self._delete_node(root.left, key)
        elif key > root.key:
            root.right = self._delete_node(root.right, key)
        else:
            # Nó com 0 ou 1 filho.
            if not root.left:
                temp = root.right
                root = None
                return temp
            elif not root.right:
                temp = root.left
                root = None
                return temp
            # Nó com 2 filhos.
            temp = self._find_min_node(root.right)
            root.key = temp.key
            root.right = self._delete_node(root.right, temp.key)

        # Se a árvore ficou vazia após a deleção, retorna.
        if not root:
            return root

        # 2. Atualiza a altura e o fator de balanceamento.
        root.height = 1 + max(self._get_height(root.left), self._get_height(root.right))
        balance = self._get_balance(root)

        # 3. Executa as rotações para re-balancear a árvore.
        # As condições são as mesmas da inserção, mas usam o fator de balanceamento dos filhos.
        
        # Rotação Simples Direita (RR)
        if balance > 1 and self._get_balance(root.left) >= 0:
            return self._rotate_right(root)

        # Rotação Dupla Esquerda-Direita (LR)
        if balance > 1 and self._get_balance(root.left) < 0:
            root.left = self._rotate_left(root.left)
            return self._rotate_right(root)

        # Rotação Simples Esquerda (LL)
        if balance < -1 and self._get_balance(root.right) <= 0:
            return self._rotate_left(root)

        # Rotação Dupla Direita-Esquerda (RL)
        if balance < -1 and self._get_balance(root.right) > 0:
            root.right = self._rotate_right(root.right)
            return self._rotate_left(root)

        return root

    # Busca uma chave na árvore.
    def search(self, key):
        return self._search_node(self.root, key)

    # Método auxiliar de busca recursiva.
    def _search_node(self, node, key):
        if node is None or node.key == key:
            return node

        if key < node.key:
            return self._search_node(node.left, key)

        return self._search_node(node.right, key)

    # Retorna a altura de um nó (ou 0 se for None).
    def _get_height(self, node):
        if node is None:
            return 0
        return node.height

    # Calcula o fator de balanceamento.
    def _get_balance(self, node):
        if node is None:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)

    # Rotação para a esquerda.
    def _rotate_left(self, z):
        y = z.right
        T2 = y.left

        y.left = z
        z.right = T2

        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))

        return y

    # Rotação para a direita.
    def _rotate_right(self, z):
        y = z.left
        T3 = y.right

        y.right = z
        z.left = T3

        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))

        return y

    # Encontra o nó com o menor valor em uma subárvore.
    def _find_min_node(self, node):
        current = node
        while current.left is not None:
            current = current.left
        return current

    # Percorre a árvore em ordem (in-order) para imprimir.
    def _inorder_traversal(self, node):
        if node is not None:
            self._inorder_traversal(node.left)
            print(node.key, end=" ")
            self._inorder_traversal(node.right)

    # Método público para imprimir a árvore.
    def print_tree(self):
        print("Árvore (percurso in-order):")
        self._inorder_traversal(self.root)
        print()

# --- Exemplo de uso do código ---
tree = AVLTree()

# Inserção
print("Inserindo chaves...")
tree.insert(10)
tree.insert(5)
tree.insert(15)
tree.insert(3)
tree.insert(7)
tree.insert(12)
tree.insert(17)
tree.print_tree() # Output: 3 5 7 10 12 15 17

# Pesquisa
print("\nPesquisando chaves...")
search_result = tree.search(7)
print(f"Chave 7 encontrada? {'Sim' if search_result else 'Não'}") # Output: Sim
search_result = tree.search(20)
print(f"Chave 20 encontrada? {'Sim' if search_result else 'Não'}") # Output: Não

# Deleção
print("\nDeletando a chave 5...")
tree.delete(5)
tree.print_tree() # Output: 3 7 10 12 15 17
