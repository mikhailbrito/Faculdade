import timeit
import matplotlib.pyplot as plt
import numpy as np
from numpy.random import randint
import sys

# Aumenta o limite de recursão para o QuickSort e MergeSort em listas grandes
sys.setrecursionlimit(200000)

# --- Implementações dos Algoritmos de Ordenação ---

# Bubble Sort (Complexidade: O(n²) no pior e médio caso)
def bubbleSort(arr):
    n = len(arr)
    for i in range(n - 1):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr

# Insertion Sort (Complexidade: O(n²) no pior e médio caso)
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Selection Sort (Complexidade: O(n²) em todos os casos)
def selectionSort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# Quicksort (Complexidade: O(n log n) no caso médio)
def partition(arr, low, high):
    i = (low - 1)
    pivot = arr[high]
    for j in range(low, high):
        if arr[j] <= pivot:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return (i + 1)

def quick_sort_recursive(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort_recursive(arr, low, pi - 1)
        quick_sort_recursive(arr, pi + 1, high)

def QuickSort(arr):
    quick_sort_recursive(arr, 0, len(arr) - 1)
    return arr

# Mergesort (Complexidade: O(n log n) em todos os casos)
def mergeSort(lista):
    if len(lista) < 2: 
        return lista
    
    meio = len(lista)//2
    
    esquerda = mergeSort(lista[:meio])
    direita = mergeSort(lista[meio:])
    
    return merge(esquerda, direita)

def merge(esquerda, direita):
    resultado = []
    i = j = 0

    while i < len(esquerda) and j < len(direita):
        if esquerda[i] < direita[j]:
            resultado.append(esquerda[i])
            i+=1
        else:
            resultado.append(direita[j])
            j+=1
    
    resultado += esquerda[i:]
    resultado += direita[j:]
    
    return resultado

# --- Lógica de Medição e Plotagem ---

def desenhaGraficoComparativo(x, y_list, labels, fileName):
    plt.style.use('seaborn-v0_8-whitegrid')
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111)

    for i in range(len(y_list)):
        ax.plot(x, y_list[i], label=labels[i])
    
    plt.title("Comparativo de Algoritmos de Ordenação")
    plt.xlabel("Tamanho da Lista")
    plt.ylabel("Tempo (segundos)")
    ax.legend()
    plt.grid(True)
    plt.savefig(fileName)
    plt.show()

if __name__ == "__main__":
    tamanhos = list(range(10000, 100001, 10000))
    
    tempos_mergesort = []
    tempos_quicksort = []
    tempos_selectionsort = []
    tempos_insertionsort = []
    tempos_bubblesort = []

    print("Iniciando medições de tempo para listas aleatórias...")

    for tam in tamanhos:
        print(f"Processando listas de tamanho {tam}...")
        
        # Gera a lista aleatória para todos os testes
        lista_aleatoria = list(randint(0, tam * 10, tam))
        
        # MergeSort
        tempo_ms = timeit.timeit(lambda: mergeSort(lista_aleatoria.copy()), number=1)
        tempos_mergesort.append(tempo_ms)

        # Quicksort
        tempo_qs = timeit.timeit(lambda: QuickSort(lista_aleatoria.copy()), number=1)
        tempos_quicksort.append(tempo_qs)

        # Selection Sort
        tempo_ss = timeit.timeit(lambda: selectionSort(lista_aleatoria.copy()), number=1)
        tempos_selectionsort.append(tempo_ss)
        
        # Insertion Sort
        tempo_is = timeit.timeit(lambda: insertionSort(lista_aleatoria.copy()), number=1)
        tempos_insertionsort.append(tempo_is)

        # Bubble Sort
        tempo_bs = timeit.timeit(lambda: bubbleSort(lista_aleatoria.copy()), number=1)
        tempos_bubblesort.append(tempo_bs)

    # Prepara os dados e rótulos para o gráfico
    tempos_comparativos = [
        tempos_mergesort,
        tempos_quicksort,
        tempos_selectionsort,
        tempos_insertionsort,
        tempos_bubblesort
    ]
    labels_comparativos = [
        'MergeSort (O(n log n))',
        'QuickSort (O(n log n))',
        'Selection Sort (O(n²))', 
        'Insertion Sort (O(n²))', 
        'Bubble Sort (O(n²))'
    ]
    
    # Desenha o gráfico
    desenhaGraficoComparativo(
        tamanhos, 
        tempos_comparativos, 
        labels_comparativos, 
        'Comparativo_Algoritmos.png'
    )
    
    print("\nProcesso finalizado. O gráfico comparativo foi gerado.")
